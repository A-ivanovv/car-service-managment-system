from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.contrib import messages
from django.core.paginator import Paginator
from django.db.models import Q
from django.db import models
from django.views.decorators.csrf import csrf_exempt
from django.template.loader import render_to_string
from django.utils import timezone
from datetime import datetime, timedelta
import json
from .models import Customer, Car, Employee, DaysOff, Event, Sklad, ImportLog, Order, OrderItem
from .forms import CustomerForm, IndividualCustomerForm, CompanyCustomerForm, CustomerSearchForm, CarFormSet, EmployeeForm, EmployeeSearchForm, DaysOffForm, SkladForm, SkladSearchForm, OrderForm, OrderItemForm, OrderSearchForm, OrderItemFormSet

def dashboard(request):
    """Main dashboard view with 6 clickable boxes and weekly planner"""
    return render(request, 'dashboard/dashboard.html')

def klienti(request):
    """Clients page with list, search, and CRUD operations"""
    search_form = CustomerSearchForm(request.GET)
    customers = Customer.objects.prefetch_related('cars').all()
    
    # Apply search filters
    if search_form.is_valid():
        search_query = search_form.cleaned_data.get('search')
        active_only = search_form.cleaned_data.get('active_only')
        customer_type = search_form.cleaned_data.get('customer_type')
        
        if search_query:
            customers = customers.filter(
                Q(customer_name__icontains=search_query) |
                Q(number__icontains=search_query) |
                Q(telno__icontains=search_query) |
                Q(customer_bulstat__icontains=search_query) |
                Q(customer_taxno__icontains=search_query) |
                Q(cars__brand_model__icontains=search_query) |
                Q(cars__vin__icontains=search_query) |
                Q(cars__plate_number__icontains=search_query)
            ).distinct()
        
        if active_only:
            customers = customers.filter(active=True)
        
        if customer_type == 'customer':
            customers = customers.filter(customer=True, supplier=False)
        elif customer_type == 'supplier':
            customers = customers.filter(supplier=True, customer=False)
        elif customer_type == 'both':
            customers = customers.filter(Q(customer=True) | Q(supplier=True))
    
    # Pagination
    paginator = Paginator(customers, 20)  # 20 customers per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'customers': page_obj,
        'search_form': search_form,
        'total_customers': customers.count(),
        'active_customers': customers.filter(active=True).count(),
    }
    return render(request, 'dashboard/klienti.html', context)

def customer_create(request):
    """Create new customer with cars"""
    customer_type = request.GET.get('type', 'individual')  # Default to individual
    
    if request.method == 'POST':
        # Determine which form to use based on customer type
        if customer_type == 'company':
            form = CompanyCustomerForm(request.POST)
        else:
            form = IndividualCustomerForm(request.POST)
        
        # Check if car formset data is provided (for modal vs full form)
        car_formset = None
        if 'cars-TOTAL_FORMS' in request.POST:
            car_formset = CarFormSet(request.POST)
        
        # Validate forms
        form_valid = form.is_valid()
        car_formset_valid = True
        if car_formset:
            car_formset_valid = car_formset.is_valid()
        
        if form_valid and car_formset_valid:
            customer = form.save(commit=False)
            # Ensure the number is set (should be auto-generated by form)
            if not customer.number:
                last_customer = Customer.objects.order_by('-number').first()
                customer.number = (last_customer.number + 1) if last_customer else 1
            customer.save()
            
            # Save cars if formset was provided
            if car_formset:
                car_formset.instance = customer
                car_formset.save()
            
            messages.success(request, f'Клиент {customer.customer_name} е създаден успешно!')
            return redirect('klienti')
        else:
            # Provide better error messages
            if not form_valid:
                for field, errors in form.errors.items():
                    for error in errors:
                        messages.error(request, f'Грешка в полето "{form.fields[field].label}": {error}')
            
            if car_formset and not car_formset_valid:
                for form_idx, car_form in enumerate(car_formset):
                    if car_form.errors:
                        for field, errors in car_form.errors.items():
                            for error in errors:
                                messages.error(request, f'Грешка в кола {form_idx + 1}, поле "{car_form.fields[field].label}": {error}')
    else:
        # Determine which form to use based on customer type
        if customer_type == 'company':
            form = CompanyCustomerForm()
        else:
            form = IndividualCustomerForm()
        
        car_formset = CarFormSet()
    
    return render(request, 'dashboard/customer_form.html', {
        'form': form,
        'car_formset': car_formset,
        'title': 'Нов клиент',
        'action': 'Създай',
        'customer_type': customer_type
    })

def get_next_customer_number(request):
    """AJAX endpoint to get the next customer number"""
    try:
        last_customer = Customer.objects.order_by('-number').first()
        if last_customer:
            next_number = last_customer.number + 1
        else:
            next_number = 1
        
        return JsonResponse({
            'success': True,
            'next_number': next_number
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        })

def customer_search_ajax(request):
    """AJAX endpoint for customer search with smart VIN logic"""
    from django.template.loader import render_to_string
    from django.core.paginator import Paginator
    
    search_query = request.GET.get('search', '').strip()
    customer_type = request.GET.get('customer_type', '')
    active_only = request.GET.get('active_only', '')
    page = int(request.GET.get('page', 1))
    
    # Start with all customers and prefetch cars for better performance
    customers = Customer.objects.prefetch_related('cars').all()
    
    # Apply filters
    if active_only:
        customers = customers.filter(active=True)
    
    if customer_type:
        if customer_type == 'company':
            customers = customers.filter(
                models.Q(customer_bulstat__isnull=False) | 
                models.Q(customer_mol__isnull=False) | 
                models.Q(customer_taxno__isnull=False)
            ).exclude(
                customer_bulstat='',
                customer_mol='',
                customer_taxno=''
            )
        elif customer_type == 'individual':
            # Individuals are customers who are NOT companies
            # Exclude customers that have any business registration data
            customers = customers.exclude(
                models.Q(customer_bulstat__isnull=False) & ~models.Q(customer_bulstat='') |
                models.Q(customer_mol__isnull=False) & ~models.Q(customer_mol='') |
                models.Q(customer_taxno__isnull=False) & ~models.Q(customer_taxno='')
            )
    
    # Apply search
    if search_query:
        # Always search by name
        search_conditions = models.Q(customer_name__icontains=search_query)
        
        # Always search by plate number (through cars)
        search_conditions |= models.Q(cars__plate_number__icontains=search_query)
        
        # Only search by VIN if search term is 5+ characters
        if len(search_query) >= 5:
            search_conditions |= models.Q(cars__vin__icontains=search_query)
        
        customers = customers.filter(search_conditions).distinct()
    
    # Order by name
    customers = customers.order_by('customer_name')
    
    # Pagination
    paginator = Paginator(customers, 10)  # 10 customers per page
    page_obj = paginator.get_page(page)
    
    # Calculate statistics
    total_customers = customers.count()
    active_customers = customers.filter(active=True).count()
    company_customers = customers.filter(
        models.Q(customer_bulstat__isnull=False) | 
        models.Q(customer_mol__isnull=False) | 
        models.Q(customer_taxno__isnull=False)
    ).exclude(
        customer_bulstat='',
        customer_mol='',
        customer_taxno=''
    ).count()
    individual_customers = total_customers - company_customers
    
    # Render table and pagination
    table_html = render_to_string('dashboard/customer_table.html', {
        'customers': page_obj,
    })
    
    pagination_html = render_to_string('dashboard/customer_pagination.html', {
        'customers': page_obj,
        'request': request,
    })
    
    return JsonResponse({
        'table_html': table_html,
        'pagination_html': pagination_html,
        'stats': {
            'total_customers': total_customers,
            'active_customers': active_customers,
            'company_customers': company_customers,
            'individual_customers': individual_customers,
            'total_pages': paginator.num_pages,
        }
    })

def customer_edit(request, pk):
    """Edit existing customer with cars"""
    customer = get_object_or_404(Customer, pk=pk)
    
    # Determine customer type and use appropriate form
    if customer.customer_type == 'Фирма':
        FormClass = CompanyCustomerForm
        customer_type = 'company'
    else:
        FormClass = IndividualCustomerForm
        customer_type = 'individual'
    
    if request.method == 'POST':
        form = FormClass(request.POST, instance=customer)
        car_formset = CarFormSet(request.POST, instance=customer)
        
        if form.is_valid() and car_formset.is_valid():
            form.save()
            car_formset.save()
            messages.success(request, f'Клиент {customer.customer_name} е обновен успешно!')
            return redirect('klienti')
    else:
        form = FormClass(instance=customer)
        car_formset = CarFormSet(instance=customer)
    
    return render(request, 'dashboard/customer_form.html', {
        'form': form,
        'car_formset': car_formset,
        'customer': customer,
        'customer_type': customer_type,
        'title': f'Редактиране на {customer.customer_name}',
        'action': 'Запази'
    })

def customer_delete(request, pk):
    """Delete customer"""
    customer = get_object_or_404(Customer, pk=pk)
    
    if request.method == 'POST':
        customer_name = customer.customer_name
        customer.delete()
        messages.success(request, f'Клиент {customer_name} е изтрит успешно!')
        return redirect('klienti')
    
    return render(request, 'dashboard/customer_confirm_delete.html', {
        'customer': customer
    })


def car_orders(request, car_id):
    """Show all orders for a specific car"""
    car = get_object_or_404(Car, pk=car_id)
    orders = Order.objects.filter(car=car).order_by('-order_date', '-created_at')
    
    # Search functionality
    search_query = request.GET.get('search', '').strip()
    if search_query:
        orders = orders.filter(
            Q(order_number__icontains=search_query) |
            Q(client_name__icontains=search_query) |
            Q(notes__icontains=search_query)
        )
    
    # Status filter
    status_filter = request.GET.get('status', '').strip()
    if status_filter:
        orders = orders.filter(status=status_filter)
    
    # Pagination
    paginator = Paginator(orders, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    return render(request, 'dashboard/car_orders.html', {
        'car': car,
        'orders': page_obj,
        'search_query': search_query,
        'status_filter': status_filter,
        'status_choices': Order.ORDER_STATUS_CHOICES,
    })


def customer_detail(request, pk):
    """View customer details with cars"""
    customer = get_object_or_404(Customer, pk=pk)
    cars = customer.cars.filter(is_active=True)
    
    # Add order counts for each car
    cars_with_orders = []
    for car in cars:
        order_count = Order.objects.filter(car=car).count()
        cars_with_orders.append({
            'car': car,
            'order_count': order_count
        })
    
    return render(request, 'dashboard/customer_detail.html', {
        'customer': customer,
        'cars': cars,
        'cars_with_orders': cars_with_orders
    })

def fakturi(request):
    """Invoices page"""
    return render(request, 'dashboard/fakturi.html')

def poruchki(request):
    """Orders page with list, search, and CRUD operations"""
    search_form = OrderSearchForm(request.GET)
    orders = Order.objects.all()
    
    # Apply search filters
    if search_form.is_valid():
        search_query = search_form.cleaned_data.get('search')
        status_filter = search_form.cleaned_data.get('status_filter')
        date_from = search_form.cleaned_data.get('date_from')
        date_to = search_form.cleaned_data.get('date_to')
        
        if search_query:
            orders = orders.filter(
                Q(order_number__icontains=search_query) |
                Q(client__customer_name__icontains=search_query) |
                Q(client_name__icontains=search_query) |
                Q(car__brand_model__icontains=search_query) |
                Q(car_brand_model__icontains=search_query) |
                Q(car_vin__icontains=search_query) |
                Q(car_plate_number__icontains=search_query)
            ).distinct()
        
        if status_filter:
            orders = orders.filter(status=status_filter)
        
        if date_from:
            orders = orders.filter(order_date__gte=date_from)
        
        if date_to:
            orders = orders.filter(order_date__lte=date_to)
    
    # Pagination
    paginator = Paginator(orders, 20)  # 20 orders per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'orders': page_obj,
        'search_form': search_form,
        'total_orders': orders.count(),
        'pending_orders': orders.filter(status='pending').count(),
        'in_progress_orders': orders.filter(status='in_progress').count(),
        'completed_orders': orders.filter(status='completed').count(),
    }
    return render(request, 'dashboard/poruchki.html', context)

def pregled_poruchki(request):
    """Order review page - list all orders with search and filters"""
    from django.db.models import Q
    from django.core.paginator import Paginator
    
    # Get all orders ordered by most recent first
    orders = Order.objects.all().order_by('-order_date', '-created_at')
    
    # Search functionality with smart VIN logic
    search_query = request.GET.get('search', '').strip()
    if search_query:
        # Always search by order number, client name, car details, and notes
        search_conditions = (
            Q(order_number__icontains=search_query) |
            Q(client_name__icontains=search_query) |
            Q(car_brand_model__icontains=search_query) |
            Q(car_plate_number__icontains=search_query) |
            Q(notes__icontains=search_query)
        )
        
        # Only search by VIN if search term is 5+ characters (smart VIN search)
        if len(search_query) >= 5:
            search_conditions |= Q(car_vin__icontains=search_query)
        
        orders = orders.filter(search_conditions)
    
    # Status filter
    status_filter = request.GET.get('status', '').strip()
    if status_filter:
        orders = orders.filter(status=status_filter)
    
    # Date range filter
    date_from = request.GET.get('date_from', '').strip()
    date_to = request.GET.get('date_to', '').strip()
    
    if date_from:
        try:
            from datetime import datetime
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            orders = orders.filter(order_date__gte=date_from_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    if date_to:
        try:
            from datetime import datetime
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            orders = orders.filter(order_date__lte=date_to_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    # Pagination
    paginator = Paginator(orders, 20)  # Show 20 orders per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Get statistics
    total_orders = Order.objects.count()
    pending_orders = Order.objects.filter(status='offer').count()
    completed_orders = Order.objects.filter(status='invoice').count()
    in_progress_orders = 0  # Not used anymore
    
    # Calculate total revenue by summing all order items with VAT
    total_revenue = 0
    for order in Order.objects.all():
        total_revenue += float(order.total_with_vat)
    
    context = {
        'orders': page_obj,
        'search_query': search_query,
        'status_filter': status_filter,
        'date_from': date_from,
        'date_to': date_to,
        'status_choices': Order.ORDER_STATUS_CHOICES,
        'total_orders': total_orders,
        'pending_orders': pending_orders,
        'completed_orders': completed_orders,
        'in_progress_orders': in_progress_orders,
        'total_revenue': total_revenue,
    }
    
    return render(request, 'dashboard/pregled_poruchki.html', context)

def order_search_ajax(request):
    """AJAX endpoint for order search with smart VIN logic"""
    from django.template.loader import render_to_string
    from django.core.paginator import Paginator
    
    search_query = request.GET.get('search', '').strip()
    status_filter = request.GET.get('status', '').strip()
    date_from = request.GET.get('date_from', '').strip()
    date_to = request.GET.get('date_to', '').strip()
    page = int(request.GET.get('page', 1))
    
    # Start with all orders ordered by most recent first
    orders = Order.objects.all().order_by('-order_date', '-created_at')
    
    # Apply search with smart VIN logic
    if search_query:
        # Always search by order number, client name, car details, and notes
        search_conditions = (
            Q(order_number__icontains=search_query) |
            Q(client_name__icontains=search_query) |
            Q(car_brand_model__icontains=search_query) |
            Q(car_plate_number__icontains=search_query) |
            Q(notes__icontains=search_query)
        )
        
        # Only search by VIN if search term is 5+ characters (smart VIN search)
        if len(search_query) >= 5:
            search_conditions |= Q(car_vin__icontains=search_query)
        
        orders = orders.filter(search_conditions)
    
    # Apply status filter
    if status_filter:
        orders = orders.filter(status=status_filter)
    
    # Apply date range filters
    if date_from:
        try:
            from datetime import datetime
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            orders = orders.filter(order_date__gte=date_from_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    if date_to:
        try:
            from datetime import datetime
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            orders = orders.filter(order_date__lte=date_to_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    # Pagination
    paginator = Paginator(orders, 20)  # 20 orders per page
    page_obj = paginator.get_page(page)
    
    # Calculate statistics
    total_orders = Order.objects.count()
    pending_orders = Order.objects.filter(status='offer').count()
    completed_orders = Order.objects.filter(status='invoice').count()
    
    # Calculate total revenue
    total_revenue = 0
    for order in Order.objects.all():
        total_revenue += float(order.total_with_vat)
    
    # Render table and pagination
    table_html = render_to_string('dashboard/order_table.html', {
        'orders': page_obj,
    })
    
    pagination_html = render_to_string('dashboard/order_pagination.html', {
        'orders': page_obj,
        'request': request,
    })
    
    return JsonResponse({
        'table_html': table_html,
        'pagination_html': pagination_html,
        'stats': {
            'total_orders': total_orders,
            'pending_orders': pending_orders,
            'completed_orders': completed_orders,
            'total_revenue': total_revenue,
            'total_pages': paginator.num_pages,
        }
    })

# This function is already defined above, removing duplicate

def sklad(request):
    """Warehouse page"""
    return render(request, 'dashboard/sklad.html')

def get_weekly_planner(request):
    """API endpoint for weekly planner data"""
    from django.db.models import Q
    
    # Get the week from request parameters
    week_offset = int(request.GET.get('week', 0))
    
    # Calculate the start of the week (Monday)
    today = datetime.now()
    start_of_week = today - timedelta(days=today.weekday()) + timedelta(weeks=week_offset)
    end_of_week = start_of_week + timedelta(days=6)
    
    # Bulgarian day names
    bulgarian_days = ['ПОН', 'ВТО', 'СРЯ', 'ЧЕТ', 'ПЕТ', 'СЪБ', 'НЕД']
    
    # Generate week days
    week_days = []
    for i in range(7):
        day = start_of_week + timedelta(days=i)
        week_days.append({
            'date': day.strftime('%Y-%m-%d'),
            'day_name': bulgarian_days[i],
            'day_number': day.day,
            'is_today': day.date() == today.date()
        })
    
    # Get employee days off for this week
    days_off = DaysOff.objects.filter(
        Q(start_date__lte=end_of_week.date()) & Q(end_date__gte=start_of_week.date()),
        is_approved=True
    ).select_related('employee')
    
    # Get events for this week
    from .models import Event
    events = Event.objects.filter(
        Q(start_datetime__date__lte=end_of_week.date()) & Q(end_datetime__date__gte=start_of_week.date())
    ).select_related('customer', 'employee')
    
    # Organize days off by date
    days_off_by_date = {}
    for day_off in days_off:
        current_date = day_off.start_date
        while current_date <= day_off.end_date:
            if start_of_week.date() <= current_date <= end_of_week.date():
                date_str = current_date.strftime('%Y-%m-%d')
                if date_str not in days_off_by_date:
                    days_off_by_date[date_str] = []
                
                days_off_by_date[date_str].append({
                    'id': day_off.id,
                    'employee_name': day_off.employee.full_name,
                    'type': day_off.get_day_off_type_display(),
                    'reason': day_off.reason or '',
                    'color': get_day_off_color(day_off.day_off_type),
                    'is_all_day': True
                })
            current_date += timedelta(days=1)
    
    # Organize events by date and time
    import pytz
    sofia_tz = pytz.timezone('Europe/Sofia')
    
    events_by_date = {}
    for event in events:
        # Convert to Sofia timezone for display
        start_local = event.start_datetime.astimezone(sofia_tz)
        end_local = event.end_datetime.astimezone(sofia_tz)
        event_date = start_local.date()
        
        if start_of_week.date() <= event_date <= end_of_week.date():
            date_str = event_date.strftime('%Y-%m-%d')
            if date_str not in events_by_date:
                events_by_date[date_str] = []
            
            events_by_date[date_str].append({
                'id': event.id,
                'title': event.title,
                'event_type': event.event_type,
                'type': event.get_event_type_display(),
                'start_date': event_date.strftime('%Y-%m-%d'),
                'start_time': start_local.strftime('%H:%M'),
                'end_time': end_local.strftime('%H:%M'),
                'is_all_day': event.is_all_day,
                'color': get_event_color(event.event_type),
                'customer': event.customer.customer_name if event.customer else None,
                'employee': event.employee.full_name if event.employee else None,
                'description': event.description or ''
            })
    
    return JsonResponse({
        'week_days': week_days,
        'current_week': week_offset == 0,
        'days_off': days_off_by_date,
        'events': events_by_date
    })


def get_day_off_color(day_off_type):
    """Get color for day off type"""
    colors = {
        'vacation': '#28a745',      # Green for vacation
        'sick': '#dc3545',          # Red for sick leave
        'personal': '#ffc107',      # Yellow for personal
        'holiday': '#6f42c1',      # Purple for holiday
        'other': '#17a2b8'          # Blue for other
    }
    return colors.get(day_off_type, '#6c757d')  # Default gray


def get_event_color(event_type):
    """Get color for event type"""
    colors = {
        'meeting': '#007bff',       # Blue for meetings
        'appointment': '#28a745',   # Green for appointments
        'maintenance': '#ffc107',   # Yellow for maintenance
        'inspection': '#fd7e14',    # Orange for inspections
        'delivery': '#6f42c1',      # Purple for deliveries
        'other': '#6c757d'          # Gray for other
    }
    return colors.get(event_type, '#6c757d')  # Default gray


@csrf_exempt
def create_event(request):
    """Create a new calendar event"""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            
            # Parse datetime with timezone
            from datetime import datetime
            import pytz
            
            # Use Sofia timezone
            tz = pytz.timezone('Europe/Sofia')
            
            start_datetime = tz.localize(datetime.strptime(
                f"{data['start_date']} {data['start_time']}", 
                '%Y-%m-%d %H:%M'
            ))
            end_datetime = tz.localize(datetime.strptime(
                f"{data['start_date']} {data['end_time']}", 
                '%Y-%m-%d %H:%M'
            ))
            
            # Check for duplicate events (same title, date, and time)
            existing_event = Event.objects.filter(
                title=data['title'],
                start_datetime=start_datetime,
                end_datetime=end_datetime
            ).first()
            
            if existing_event:
                return JsonResponse({
                    'success': False,
                    'error': 'Събитие с това заглавие и време вече съществува!'
                })
            
            # Create event
            event = Event.objects.create(
                title=data['title'],
                event_type=data['event_type'],
                start_datetime=start_datetime,
                end_datetime=end_datetime,
                description=data.get('description', ''),
                is_all_day=data.get('is_all_day', False)
            )
            
            return JsonResponse({
                'success': True,
                'event_id': event.id
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            })
    
    return JsonResponse({'success': False, 'error': 'Invalid method'})


@csrf_exempt
def update_event(request):
    """Update an existing calendar event"""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            event_id = data.get('id')
            
            if not event_id:
                return JsonResponse({
                    'success': False,
                    'error': 'Event ID is required'
                })
            
            try:
                event = Event.objects.get(id=event_id)
            except Event.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Event not found'
                })
            
            # Parse datetime with timezone
            from datetime import datetime
            import pytz
            
            # Use Sofia timezone
            tz = pytz.timezone('Europe/Sofia')
            
            start_datetime = tz.localize(datetime.strptime(
                f"{data['start_date']} {data['start_time']}", 
                '%Y-%m-%d %H:%M'
            ))
            end_datetime = tz.localize(datetime.strptime(
                f"{data['start_date']} {data['end_time']}", 
                '%Y-%m-%d %H:%M'
            ))
            
            # Update event
            event.title = data['title']
            event.event_type = data['event_type']
            event.start_datetime = start_datetime
            event.end_datetime = end_datetime
            event.description = data.get('description', '')
            event.is_all_day = data.get('is_all_day', False)
            
            # Handle customer - try to find by name or set to None
            customer_name = data.get('customer', '')
            if customer_name:
                try:
                    customer = Customer.objects.get(customer_name=customer_name)
                    event.customer = customer
                except Customer.DoesNotExist:
                    # If customer doesn't exist, we'll leave it as None
                    # In a real app, you might want to create the customer
                    event.customer = None
            else:
                event.customer = None
                
            event.save()
            
            return JsonResponse({
                'success': True,
                'event_id': event.id
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            })
    
    return JsonResponse({'success': False, 'error': 'Invalid method'})


@csrf_exempt
def delete_event(request):
    """Delete a calendar event"""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            event_id = data.get('id')
            
            if not event_id:
                return JsonResponse({
                    'success': False,
                    'error': 'Event ID is required'
                })
            
            try:
                event = Event.objects.get(id=event_id)
                event.delete()
                
                return JsonResponse({
                    'success': True,
                    'message': 'Event deleted successfully'
                })
                
            except Event.DoesNotExist:
                return JsonResponse({
                    'success': False,
                    'error': 'Event not found'
                })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            })
    
    return JsonResponse({'success': False, 'error': 'Invalid method'})


# Employee Views
def slujiteli(request):
    """Employee list with search and pagination"""
    employees = Employee.objects.all()
    search_form = EmployeeSearchForm(request.GET)
    
    if search_form.is_valid():
        search_query = search_form.cleaned_data.get('search')
        active_only = search_form.cleaned_data.get('active_only')
        
        if search_query:
            employees = employees.filter(
                Q(first_name__icontains=search_query) |
                Q(last_name__icontains=search_query)
            )
        
        if active_only:
            employees = employees.filter(is_active=True)
    
    # Pagination
    paginator = Paginator(employees, 20)  # 20 employees per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'employees': page_obj,
        'search_form': search_form,
        'total_employees': employees.count(),
        'active_employees': employees.filter(is_active=True).count(),
    }
    return render(request, 'dashboard/slujiteli.html', context)


def employee_create(request):
    """Create new employee"""
    if request.method == 'POST':
        form = EmployeeForm(request.POST)
        if form.is_valid():
            employee = form.save()
            messages.success(request, f'Служител {employee.full_name} е създаден успешно!')
            return redirect('slujiteli')
    else:
        form = EmployeeForm()
    
    return render(request, 'dashboard/employee_form.html', {
        'form': form,
        'title': 'Нов служител',
        'action': 'Създай'
    })


def employee_edit(request, pk):
    """Edit existing employee"""
    employee = get_object_or_404(Employee, pk=pk)
    
    if request.method == 'POST':
        form = EmployeeForm(request.POST, instance=employee)
        if form.is_valid():
            form.save()
            messages.success(request, f'Служител {employee.full_name} е обновен успешно!')
            return redirect('slujiteli')
    else:
        form = EmployeeForm(instance=employee)
    
    return render(request, 'dashboard/employee_form.html', {
        'form': form,
        'employee': employee,
        'title': f'Редактиране на {employee.full_name}',
        'action': 'Запази'
    })


def employee_delete(request, pk):
    """Delete employee"""
    employee = get_object_or_404(Employee, pk=pk)
    
    if request.method == 'POST':
        employee_name = employee.full_name
        employee.delete()
        messages.success(request, f'Служител {employee_name} е изтрит успешно!')
        return redirect('slujiteli')
    
    return render(request, 'dashboard/employee_confirm_delete.html', {
        'employee': employee
    })


def employee_detail(request, pk):
    """View employee details with days off"""
    from datetime import date
    
    employee = get_object_or_404(Employee, pk=pk)
    days_off = employee.days_off.all().order_by('-start_date')
    current_year = date.today().year
    
    return render(request, 'dashboard/employee_detail.html', {
        'employee': employee,
        'days_off': days_off,
        'current_year': current_year
    })


def days_off_create(request):
    """Create new days off request"""
    if request.method == 'POST':
        form = DaysOffForm(request.POST)
        if form.is_valid():
            days_off = form.save()
            messages.success(request, f'Заявка за отпуск е създадена успешно!')
            return redirect('employee_detail', pk=days_off.employee.pk)
    else:
        form = DaysOffForm()
    
    return render(request, 'dashboard/days_off_form.html', {
        'form': form,
        'title': 'Нова заявка за отпуск',
        'action': 'Създай'
    })


def days_off_edit(request, pk):
    """Edit days off request"""
    days_off = get_object_or_404(DaysOff, pk=pk)
    
    if request.method == 'POST':
        form = DaysOffForm(request.POST, instance=days_off)
        if form.is_valid():
            form.save()
            messages.success(request, f'Заявка за отпуск е обновена успешно!')
            return redirect('employee_detail', pk=days_off.employee.pk)
    else:
        form = DaysOffForm(instance=days_off)
    
    return render(request, 'dashboard/days_off_form.html', {
        'form': form,
        'days_off': days_off,
        'title': f'Редактиране на заявка за отпуск',
        'action': 'Запази'
    })


def days_off_delete(request, pk):
    """Delete days off request"""
    days_off = get_object_or_404(DaysOff, pk=pk)
    employee_pk = days_off.employee.pk
    
    if request.method == 'POST':
        days_off.delete()
        messages.success(request, f'Заявка за отпуск е изтрита успешно!')
        return redirect('employee_detail', pk=employee_pk)
    
    return render(request, 'dashboard/days_off_confirm_delete.html', {
        'days_off': days_off
    })


@csrf_exempt
def cleanup_duplicate_events(request):
    """Clean up duplicate events from the database"""
    if request.method == 'POST':
        try:
            # Find duplicate events (same title, start_datetime, end_datetime)
            from django.db.models import Count
            
            duplicates = Event.objects.values('title', 'start_datetime', 'end_datetime').annotate(
                count=Count('id')
            ).filter(count__gt=1)
            
            removed_count = 0
            
            for duplicate in duplicates:
                # Get all events with this combination
                events = Event.objects.filter(
                    title=duplicate['title'],
                    start_datetime=duplicate['start_datetime'],
                    end_datetime=duplicate['end_datetime']
                ).order_by('id')
                
                # Keep the first one, delete the rest
                events_to_delete = events[1:]
                for event in events_to_delete:
                    event.delete()
                    removed_count += 1
            
            return JsonResponse({
                'success': True,
                'removed_count': removed_count,
                'message': f'Премахнати са {removed_count} дублирани събития.'
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            })
    
    return JsonResponse({'success': False, 'error': 'Invalid method'})
def sklad(request):
    """Warehouse/Inventory page with list, search, and CRUD operations"""
    search_form = SkladSearchForm(request.GET)
    items = Sklad.objects.all()
    
    # Apply search filters
    if search_form.is_valid():
        search_query = search_form.cleaned_data.get('search')
        active_only = search_form.cleaned_data.get('active_only')
        unit_filter = search_form.cleaned_data.get('unit_filter')
        
        if search_query:
            items = items.filter(
                Q(article_number__icontains=search_query) |
                Q(name__icontains=search_query)
            ).distinct()
        
        if active_only:
            items = items.filter(is_active=True)
        
        if unit_filter:
            items = items.filter(unit=unit_filter)
    
    # Pagination
    paginator = Paginator(items, 20)  # 20 items per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Calculate total value
    total_value = sum(item.total_value for item in items if item.is_active)
    
    # Check if this is an AJAX request
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.GET.get('ajax'):
        # Return JSON response for AJAX requests
        table_html = render_to_string('dashboard/sklad_table.html', {
            'page_obj': page_obj,
        })
        
        pagination_html = render_to_string('dashboard/sklad_pagination.html', {
            'page_obj': page_obj,
            'request': request,
        })
        
        return JsonResponse({
            'table_html': table_html,
            'pagination_html': pagination_html,
            'stats': {
                'total_items': items.count(),
                'active_items': items.filter(is_active=True).count(),
                'total_value': float(total_value),
                'total_pages': paginator.num_pages,
            }
        })
    
    context = {
        'page_obj': page_obj,
        'search_form': search_form,
        'total_value': total_value,
        'total_items': items.count(),
        'active_items': items.filter(is_active=True).count(),
    }
    
    return render(request, 'dashboard/sklad.html', context)


def sklad_create(request):
    """Create new warehouse item"""
    if request.method == 'POST':
        form = SkladForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Артикулът е създаден успешно!')
            return redirect('sklad')
    else:
        form = SkladForm()
    
    return render(request, 'dashboard/sklad_form.html', {
        'form': form,
        'title': 'Създаване на нов артикул',
        'action': 'Създай'
    })


def sklad_detail(request, pk):
    """View warehouse item details"""
    item = get_object_or_404(Sklad, pk=pk)
    return render(request, 'dashboard/sklad_detail.html', {
        'item': item
    })


def sklad_edit(request, pk):
    """Edit warehouse item"""
    item = get_object_or_404(Sklad, pk=pk)
    
    if request.method == 'POST':
        form = SkladForm(request.POST, instance=item)
        if form.is_valid():
            form.save()
            messages.success(request, 'Артикулът е обновен успешно!')
            return redirect('sklad_detail', pk=item.pk)
    else:
        form = SkladForm(instance=item)
    
    return render(request, 'dashboard/sklad_form.html', {
        'form': form,
        'item': item,
        'title': 'Редактиране на артикул',
        'action': 'Запази'
    })


def sklad_delete(request, pk):
    """Delete warehouse item"""
    item = get_object_or_404(Sklad, pk=pk)
    
    if request.method == 'POST':
        item.delete()
        messages.success(request, 'Артикулът е изтрит успешно!')
        return redirect('sklad')
    
    return render(request, 'dashboard/sklad_confirm_delete.html', {
        'item': item
    })


def sklad_autocomplete(request):
    """API endpoint for autocomplete suggestions"""
    query = request.GET.get('q', '').strip()
    field = request.GET.get('field', 'article_number')  # 'article_number' or 'name'
    
    if not query or len(query) < 2:
        return JsonResponse({'suggestions': []})
    
    # Validate field parameter
    if field not in ['article_number', 'name']:
        field = 'article_number'
    
    # Search for matching items
    items = Sklad.objects.filter(
        **{f'{field}__icontains': query}
    ).values('id', 'article_number', 'name', 'unit', 'quantity', 'purchase_price')[:10]
    
    suggestions = []
    for item in items:
        suggestions.append({
            'id': item['id'],
            'article_number': item['article_number'],
            'name': item['name'],
            'unit': item['unit'],
            'quantity': float(item['quantity']),
            'purchase_price': float(item['purchase_price']),
            'display_text': f"{item['article_number']} - {item['name']}"
        })
    
    return JsonResponse({'suggestions': suggestions})


@csrf_exempt
def sklad_import(request):
    """Handle file imports for different providers"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Invalid request method'})
    
    try:
        provider = request.POST.get('provider')
        file = request.FILES.get('file')
        update_existing = request.POST.get('update_existing') == 'on'
        
        if not provider or not file:
            return JsonResponse({'success': False, 'error': 'Missing provider or file'})
        
        # Validate file type based on provider
        if provider in ['starts94', 'peugeot']:
            if not file.name.lower().endswith('.pdf'):
                return JsonResponse({'success': False, 'error': 'Invalid file type. Expected PDF for this provider.'})
        elif provider == 'nalichnosti':
            if not file.name.lower().endswith('.xlsx'):
                return JsonResponse({'success': False, 'error': 'Invalid file type. Expected Excel (.xlsx) for this provider.'})
        
        # Additional content validation and duplicate check
        try:
            if provider == 'nalichnosti':
                # Validate Excel content
                import openpyxl
                workbook = openpyxl.load_workbook(file)
                if not workbook.active or workbook.active.max_row < 8:
                    return JsonResponse({'success': False, 'error': 'Invalid Excel file. File appears to be empty or corrupted.'})
                
                # Extract content for duplicate check
                first_page_text = ""
                for row in workbook.active.iter_rows(max_row=10, values_only=True):
                    first_page_text += " ".join([str(cell) for cell in row if cell]) + " "
                    
            elif provider in ['starts94', 'peugeot']:
                # Validate PDF content
                import pdfplumber
                with pdfplumber.open(file) as pdf:
                    if len(pdf.pages) == 0:
                        return JsonResponse({'success': False, 'error': 'Invalid PDF file. File appears to be empty or corrupted.'})
                    # Extract first page text to check if it's readable
                    first_page_text = pdf.pages[0].extract_text()
                    if not first_page_text or len(first_page_text.strip()) < 50:
                        return JsonResponse({'success': False, 'error': 'Invalid PDF file. File appears to be unreadable or corrupted.'})
            
            # Check for duplicate imports
            from .import_utils import extract_invoice_info, check_duplicate_import, get_duplicate_import_info
            
            invoice_number, invoice_date = extract_invoice_info(first_page_text, provider)
            
            if check_duplicate_import(provider, invoice_number, invoice_date):
                duplicate_info = get_duplicate_import_info(provider, invoice_number, invoice_date)
                return JsonResponse({
                    'success': False, 
                    'error': 'duplicate',
                    'duplicate_info': duplicate_info,
                    'message': f'Тази фактура вече е импортирана на {duplicate_info["import_date"].strftime("%d.%m.%Y %H:%M")} от файл {duplicate_info["file_name"]}'
                })
                
        except Exception as e:
            return JsonResponse({'success': False, 'error': f'File validation failed: {str(e)}'})
        
        # Process based on provider
        if provider == 'nalichnosti':
            result = import_nalichnosti_excel(file, update_existing)
        elif provider == 'starts94':
            result = import_starts94_pdf(file, update_existing)
        elif provider == 'peugeot':
            result = import_peugeot_pdf(file, update_existing)
        else:
            return JsonResponse({'success': False, 'error': 'Unknown provider'})
        
        # Create ImportLog entry
        try:
            from .import_utils import generate_import_identifier
            import_identifier = generate_import_identifier(provider, invoice_number, invoice_date)
            
            ImportLog.objects.create(
                provider=provider,
                invoice_date=result.get('invoice_date'),
                invoice_number=invoice_number,
                import_identifier=import_identifier,
                file_name=file.name,
                items_created=result.get('created', 0),
                items_updated=result.get('updated', 0),
                errors_count=result.get('errors', 0),
                skipped_count=result.get('skipped', 0),
                total_processed=result.get('total', 0),
                is_successful=True,
                affected_items=result.get('affected_items', {'created': [], 'updated': []})
            )
        except Exception as e:
            # Log the error but don't fail the import
            print(f"Error creating ImportLog: {e}")
        
        return JsonResponse({
            'success': True,
            'created': result.get('created', 0),
            'updated': result.get('updated', 0),
            'errors': result.get('errors', 0),
            'total': result.get('total', 0)
        })
        
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


def import_nalichnosti_excel(file, update_existing=False):
    """Import from НАЛИЧНОСТИ Excel file"""
    import openpyxl
    from decimal import Decimal
    from datetime import datetime
    import re
    
    created_count = 0
    updated_count = 0
    errors_count = 0
    skipped_count = 0
    affected_items = {
        'created': [],
        'updated': []
    }
    invoice_date = None
    
    try:
        workbook = openpyxl.load_workbook(file)
        sheet = workbook.active
        
        # Validate that this looks like a НАЛИЧНОСТИ Excel file
        # Check if it has the expected structure (header row around row 7-8)
        header_found = False
        for row_idx in range(1, 10):  # Check first 10 rows for headers
            row_data = [str(cell.value).lower() if cell.value else '' for cell in sheet[row_idx]]
            if any(keyword in ' '.join(row_data) for keyword in ['артикул', 'наименование', 'наличност', 'цена']):
                header_found = True
                break
        
        if not header_found:
            raise Exception("This doesn't appear to be a НАЛИЧНОСТИ Excel file. Please verify the provider selection.")
        
        # Extract invoice date from the first few rows
        # Look for various date patterns in НАЛИЧНОСТИ files
        for row_idx in range(1, 15):  # Check more rows
            row_data = [str(cell.value) if cell.value else '' for cell in sheet[row_idx]]
            row_text = ' '.join(row_data)
            
            
            # Try multiple date patterns
            date_patterns = [
                # Pattern 1: "Към дата 2025-09-04 00:00:00" (ISO format)
                r'Към дата\s+(\d{4}-\d{1,2}-\d{1,2})',
                # Pattern 2: "Към дата 4.9.2025 'г.'" or "Към дата 04/09/2025"
                r'Към дата\s+(\d{1,2}[./]\d{1,2}[./]\d{4})',
                # Pattern 3: "Дата: 04/09/2025" or "Дата: 4.9.2025"
                r'Дата:\s*(\d{1,2}[./]\d{1,2}[./]\d{4})',
                # Pattern 4: Just look for date patterns in the text
                r'(\d{1,2}[./]\d{1,2}[./]\d{4})',
            ]
            
            for pattern in date_patterns:
                date_match = re.search(pattern, row_text)
                if date_match:
                    try:
                        date_str = date_match.group(1)
                        # Try different date formats
                        for date_format in ['%Y-%m-%d', '%d.%m.%Y', '%d/%m/%Y', '%d.%m.%y', '%d/%m/%y']:
                            try:
                                invoice_date = datetime.strptime(date_str, date_format).date()
                                # If year is 2 digits, assume 20xx
                                if len(date_str.split('.')[-1]) == 2 or len(date_str.split('/')[-1]) == 2:
                                    year = invoice_date.year
                                    if year < 2000:
                                        invoice_date = invoice_date.replace(year=year + 2000)
                                break
                            except ValueError:
                                continue
                        if invoice_date:
                            break
                    except (ValueError, AttributeError):
                        continue
            if invoice_date:
                break
        
        # If no date found, use current date
        if not invoice_date:
            invoice_date = datetime.now().date()
        
        # Start from row 8 (as per existing logic)
        for row_idx in range(8, sheet.max_row + 1):
            row_data = [cell.value for cell in sheet[row_idx]]
            
            # Skip empty rows
            if not any(row_data):
                skipped_count += 1
                continue
                
            # Assuming columns: A=Article Number, B=Name, F=Unit, G=Quantity, H=Purchase Price
            article_number = str(row_data[0]).strip() if row_data[0] else None
            name = str(row_data[1]).strip() if row_data[1] else None
            unit = str(row_data[5]).strip() if row_data[5] else None
            quantity_raw = row_data[6]
            purchase_price_raw = row_data[7]
            
            # Skip rows without essential data
            if not article_number or not name or article_number == 'None' or name == 'None':
                skipped_count += 1
                continue
                
            # Skip header rows (check if article_number looks like a header)
            if any(header_word in article_number.lower() for header_word in ['артикул', 'наименование', 'номер', 'код']):
                skipped_count += 1
                continue
            
            try:
                quantity = Decimal(str(quantity_raw).replace(',', '.')) if quantity_raw else Decimal('0.00')
                purchase_price = Decimal(str(purchase_price_raw).replace(',', '.')) if purchase_price_raw else Decimal('0.00')
                
                # Round to 2 decimal places to match database precision
                quantity = quantity.quantize(Decimal('0.01'))
                purchase_price = purchase_price.quantize(Decimal('0.01'))
            except (ValueError, TypeError):
                errors_count += 1
                continue
            
            
            try:
                if update_existing:
                    sklad_item, created = Sklad.objects.get_or_create(
                        article_number=article_number,
                        defaults={
                            'name': name,
                            'unit': unit,
                            'quantity': quantity,
                            'purchase_price': purchase_price,
                            'is_active': True
                        }
                    )
                    if created:
                        created_count += 1
                        affected_items['created'].append({
                            'article_number': article_number,
                            'name': name,
                            'unit': unit,
                            'quantity': float(quantity),
                            'purchase_price': float(purchase_price)
                        })
                    else:
                        # Check if any values have actually changed
                        has_changes = False
                        changes_log = []
                        old_values = {
                            'name': sklad_item.name,
                            'unit': sklad_item.unit,
                            'quantity': float(sklad_item.quantity),
                            'purchase_price': float(sklad_item.purchase_price),
                            'is_active': sklad_item.is_active
                        }
                        
                        if sklad_item.name != name:
                            changes_log.append(f"name: '{sklad_item.name}' -> '{name}'")
                            sklad_item.name = name
                            has_changes = True
                        if sklad_item.unit != unit:
                            changes_log.append(f"unit: '{sklad_item.unit}' -> '{unit}'")
                            sklad_item.unit = unit
                            has_changes = True
                        # Add imported quantity to existing quantity instead of replacing
                        if quantity > 0:  # Only add if we have a positive quantity to add
                            old_quantity = sklad_item.quantity
                            new_quantity = sklad_item.quantity + quantity
                            changes_log.append(f"quantity: {old_quantity} -> {new_quantity} (added {quantity})")
                            sklad_item.quantity = new_quantity
                            has_changes = True
                        if sklad_item.purchase_price != purchase_price:
                            changes_log.append(f"purchase_price: {sklad_item.purchase_price} -> {purchase_price}")
                            sklad_item.purchase_price = purchase_price
                            has_changes = True
                        if not sklad_item.is_active:
                            changes_log.append(f"is_active: {sklad_item.is_active} -> True")
                            sklad_item.is_active = True
                            has_changes = True
                        
                        if has_changes:
                            sklad_item.save()
                            updated_count += 1
                            affected_items['updated'].append({
                                'article_number': article_number,
                                'name': name,
                                'unit': unit,
                                'quantity': float(sklad_item.quantity),  # Use final quantity after addition
                                'purchase_price': float(purchase_price),
                                'old_values': old_values,
                                'changes': changes_log
                            })
                        else:
                            # No changes needed, count as skipped
                            skipped_count += 1
                else:
                    sklad_item, created = Sklad.objects.get_or_create(
                        article_number=article_number,
                        defaults={
                            'name': name,
                            'unit': unit,
                            'quantity': quantity,
                            'purchase_price': purchase_price,
                            'is_active': True
                        }
                    )
                    if created:
                        created_count += 1
                    else:
                        errors_count += 1  # Item already exists and we're not updating
                        
            except Exception as e:
                errors_count += 1
                continue
                
    except Exception as e:
        raise Exception(f"Error processing Excel file: {str(e)}")
    
    return {
        'created': created_count,
        'updated': updated_count,
        'errors': errors_count,
        'skipped': skipped_count,
        'total': created_count + updated_count + errors_count + skipped_count,
        'invoice_date': invoice_date,
        'affected_items': affected_items
    }


def import_starts94_pdf(file, update_existing=False):
    """Import from Старс 94 PDF file""" 
    import pdfplumber
    import re
    from decimal import Decimal
    from datetime import datetime
    
    created_count = 0
    updated_count = 0
    errors_count = 0
    skipped_count = 0
    invoice_date = None
    affected_items = {
        'created': [],
        'updated': []
    }
    
    try:
        with pdfplumber.open(file) as pdf:
            text = ""
            for page in pdf.pages:
                text += page.extract_text() or ""
        
        # Validate that this looks like a Старс 94 PDF
        if not any(keyword in text.lower() for keyword in ['старс', 'starts', '94']):
            raise Exception("This doesn't appear to be a Старс 94 PDF file. Please verify the provider selection.")
        
        # Extract invoice date
        # Look for pattern like "Дата: 09.09.2025"
        date_match = re.search(r'Дата:\s+(\d+\.\d+\.\d+)', text)
        if date_match:
            try:
                date_str = date_match.group(1)
                # Parse date in format dd.mm.yyyy
                invoice_date = datetime.strptime(date_str, '%d.%m.%Y').date()
            except ValueError:
                pass
        
        # If no date found, use current date
        if not invoice_date:
            invoice_date = datetime.now().date()
        
        # Parse PDF text to extract items
        # Format: № Код Наименование Мярка К-во Цена Т.О. % Общо(с ДДС)
        # Example: 1 OE 9674994180 гарнитура инжекционна помпа БР 1.00 4.80 30 3.36
        lines = text.split('\n')
        
        for line in lines:
            # Look for patterns that match article data
            # Format: № Код Наименование Мярка К-во Цена Т.О. % Общо(с ДДС)
            # Updated regex to capture TO% and final price
            match = re.search(r'\d+\s+([A-Z]+\s+[A-Z0-9]+)\s+(.+?)\s+(\w+)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)', line)
            if match:
                article_number = match.group(1).strip()  # Код
                name = match.group(2).strip()           # Наименование
                unit = match.group(3).strip()           # Мярка
                quantity = Decimal(match.group(4)).quantize(Decimal('0.01'))      # К-во
                base_price = Decimal(match.group(5)).quantize(Decimal('0.01'))    # Цена
                to_percentage = Decimal(match.group(6)).quantize(Decimal('0.01'))  # Т.О. %
                final_price = Decimal(match.group(7)).quantize(Decimal('0.01'))   # Общо(с ДДС)
                
                # Calculate the actual purchase price using TO% discount
                # Formula: total_price = (base_price * quantity) * (1 - to_percentage/100)
                # Then: unit_price = total_price / quantity
                total_base_price = base_price * quantity
                total_discounted_price = (total_base_price * (1 - to_percentage / 100)).quantize(Decimal('0.01'))
                purchase_price = (total_discounted_price / quantity).quantize(Decimal('0.01'))
                
                try:
                    if update_existing:
                        sklad_item, created = Sklad.objects.get_or_create(
                            article_number=article_number,
                            defaults={
                                'name': name,
                                'unit': unit,  # Use actual unit from PDF
                                'quantity': quantity,
                                'purchase_price': purchase_price,
                                'is_active': True
                            }
                        )
                        if created:
                            created_count += 1
                            affected_items['created'].append({
                                'article_number': article_number,
                                'name': name,
                                'unit': unit,
                                'quantity': float(quantity),
                                'purchase_price': float(purchase_price)
                            })
                        else:
                            # Check if any values have actually changed
                            has_changes = False
                            changes_log = []
                            old_values = {
                                'name': sklad_item.name,
                                'unit': sklad_item.unit,
                                'quantity': float(sklad_item.quantity),
                                'purchase_price': float(sklad_item.purchase_price),
                                'is_active': sklad_item.is_active
                            }
                            
                            if sklad_item.name != name:
                                changes_log.append(f"name: '{sklad_item.name}' -> '{name}'")
                                sklad_item.name = name
                                has_changes = True
                            if sklad_item.unit != unit:
                                changes_log.append(f"unit: '{sklad_item.unit}' -> '{unit}'")
                                sklad_item.unit = unit
                                has_changes = True
                            # Add imported quantity to existing quantity instead of replacing
                            if quantity > 0:  # Only add if we have a positive quantity to add
                                old_quantity = sklad_item.quantity
                                new_quantity = sklad_item.quantity + quantity
                                changes_log.append(f"quantity: {old_quantity} -> {new_quantity} (added {quantity})")
                                sklad_item.quantity = new_quantity
                                has_changes = True
                            if sklad_item.purchase_price != purchase_price:
                                changes_log.append(f"purchase_price: {sklad_item.purchase_price} -> {purchase_price}")
                                sklad_item.purchase_price = purchase_price
                                has_changes = True
                            if not sklad_item.is_active:
                                changes_log.append(f"is_active: {sklad_item.is_active} -> True")
                                sklad_item.is_active = True
                                has_changes = True
                            
                            if has_changes:
                                sklad_item.save()
                                updated_count += 1
                                affected_items['updated'].append({
                                    'article_number': article_number,
                                    'name': name,
                                    'unit': unit,
                                    'quantity': float(sklad_item.quantity),  # Use final quantity after addition
                                    'purchase_price': float(purchase_price),
                                    'old_values': old_values,
                                    'changes': changes_log
                                })
                            else:
                                # No changes needed, count as skipped
                                skipped_count += 1
                    else:
                        sklad_item, created = Sklad.objects.get_or_create(
                            article_number=article_number,
                            defaults={
                                'name': name,
                                'unit': unit,  # Use actual unit from PDF
                                'quantity': quantity,
                                'purchase_price': purchase_price,
                                'is_active': True
                            }
                        )
                        if created:
                            created_count += 1
                        else:
                            errors_count += 1
                            
                except Exception as e:
                    errors_count += 1
                    continue
                    
    except Exception as e:
        raise Exception(f"Error processing Старс 94 PDF: {str(e)}")
    
    return {
        'created': created_count,
        'updated': updated_count,
        'errors': errors_count,
        'skipped': skipped_count,
        'total': created_count + updated_count + errors_count + skipped_count,
        'invoice_date': invoice_date,
        'affected_items': affected_items
    }


def import_peugeot_pdf(file, update_existing=False):
    """Import from Пежо PDF file"""
    import pdfplumber
    import re
    from decimal import Decimal
    from datetime import datetime
    
    created_count = 0
    updated_count = 0
    errors_count = 0
    skipped_count = 0
    affected_items = {
        'created': [],
        'updated': []
    }
    invoice_date = None
    
    try:
        with pdfplumber.open(file) as pdf:
            text = ""
            for page in pdf.pages:
                text += page.extract_text() or ""
        
        # Validate that this looks like a Пежо PDF
        if not any(keyword in text.lower() for keyword in ['пежо', 'peugeot', 'peugeot']):
            raise Exception("This doesn't appear to be a Пежо PDF file. Please verify the provider selection.")
        
        # Extract invoice date
        # Look for pattern like "Дата на данъчно събитие:21.08.25"
        date_match = re.search(r'Дата на данъчно събитие:\s*(\d+\.\d+\.\d+)', text)
        if date_match:
            try:
                date_str = date_match.group(1)
                # Parse date in format dd.mm.yy (assuming 20xx for years < 50)
                if len(date_str.split('.')[-1]) == 2:
                    year = int(date_str.split('.')[-1])
                    if year < 50:
                        year += 2000
                    else:
                        year += 1900
                    date_str = date_str[:-2] + str(year)
                invoice_date = datetime.strptime(date_str, '%d.%m.%Y').date()
            except ValueError:
                pass
        
        # If no date found, use current date
        if not invoice_date:
            invoice_date = datetime.now().date()
        
        # Parse PDF text to extract items
        # Format: Катал.No Наименование Кол. МЕ Ед.цена TO% Общо
        # Example: 1680233580 МАСЛЕН ФИЛТЪР ERP 4.00 Брой 13.51 40.0 32.44
        lines = text.split('\n')
        
        for line in lines:
            # Look for patterns that match article data
            # Format: Катал.No Наименование Кол. МЕ Ед.цена TO% Общо
            match = re.search(r'(\w+)\s+(.+?)\s+(\d+\.?\d*)\s+(\w+)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)', line)
            if match:
                article_number = match.group(1).strip()
                name = match.group(2).strip()
                quantity = Decimal(match.group(3)).quantize(Decimal('0.01'))  # Кол.
                unit = match.group(4).strip()      # МЕ
                base_price = Decimal(match.group(5)).quantize(Decimal('0.01'))  # Ед.цена
                to_percentage = Decimal(match.group(6)).quantize(Decimal('0.01'))  # TO%
                final_price = Decimal(match.group(7)).quantize(Decimal('0.01'))  # Общо
                
                # Calculate the actual purchase price using TO% discount
                # Formula: total_price = (base_price * quantity) * (1 - to_percentage/100)
                # Then: unit_price = total_price / quantity
                total_base_price = base_price * quantity
                total_discounted_price = (total_base_price * (1 - to_percentage / 100)).quantize(Decimal('0.01'))
                purchase_price = (total_discounted_price / quantity).quantize(Decimal('0.01'))
                
                try:
                    if update_existing:
                        sklad_item, created = Sklad.objects.get_or_create(
                            article_number=article_number,
                            defaults={
                                'name': name,
                                'unit': unit,  # Use actual unit from PDF
                                'quantity': quantity,
                                'purchase_price': purchase_price,
                                'is_active': True
                            }
                        )
                        if created:
                            created_count += 1
                            affected_items['created'].append({
                                'article_number': article_number,
                                'name': name,
                                'unit': unit,
                                'quantity': float(quantity),
                                'purchase_price': float(purchase_price)
                            })
                        else:
                            # Check if any values have actually changed
                            has_changes = False
                            changes_log = []
                            old_values = {
                                'name': sklad_item.name,
                                'unit': sklad_item.unit,
                                'quantity': float(sklad_item.quantity),
                                'purchase_price': float(sklad_item.purchase_price),
                                'is_active': sklad_item.is_active
                            }
                            
                            if sklad_item.name != name:
                                changes_log.append(f"name: '{sklad_item.name}' -> '{name}'")
                                sklad_item.name = name
                                has_changes = True
                            if sklad_item.unit != unit:
                                changes_log.append(f"unit: '{sklad_item.unit}' -> '{unit}'")
                                sklad_item.unit = unit
                                has_changes = True
                            # Add imported quantity to existing quantity instead of replacing
                            if quantity > 0:  # Only add if we have a positive quantity to add
                                old_quantity = sklad_item.quantity
                                new_quantity = sklad_item.quantity + quantity
                                changes_log.append(f"quantity: {old_quantity} -> {new_quantity} (added {quantity})")
                                sklad_item.quantity = new_quantity
                                has_changes = True
                            if sklad_item.purchase_price != purchase_price:
                                changes_log.append(f"purchase_price: {sklad_item.purchase_price} -> {purchase_price}")
                                sklad_item.purchase_price = purchase_price
                                has_changes = True
                            if not sklad_item.is_active:
                                changes_log.append(f"is_active: {sklad_item.is_active} -> True")
                                sklad_item.is_active = True
                                has_changes = True
                            
                            if has_changes:
                                sklad_item.save()
                                updated_count += 1
                                affected_items['updated'].append({
                                    'article_number': article_number,
                                    'name': name,
                                    'unit': unit,
                                    'quantity': float(sklad_item.quantity),  # Use final quantity after addition
                                    'purchase_price': float(purchase_price),
                                    'old_values': old_values,
                                    'changes': changes_log
                                })
                            else:
                                # No changes needed, count as skipped
                                skipped_count += 1
                    else:
                        sklad_item, created = Sklad.objects.get_or_create(
                            article_number=article_number,
                            defaults={
                                'name': name,
                                'unit': unit,  # Use actual unit from PDF
                                'quantity': quantity,
                                'purchase_price': purchase_price,
                                'is_active': True
                            }
                        )
                        if created:
                            created_count += 1
                        else:
                            errors_count += 1
                            
                except Exception as e:
                    errors_count += 1
                    continue
                    
    except Exception as e:
        raise Exception(f"Error processing Пежо PDF: {str(e)}")
    
    return {
        'created': created_count,
        'updated': updated_count,
        'errors': errors_count,
        'skipped': skipped_count,
        'total': created_count + updated_count + errors_count + skipped_count,
        'invoice_date': invoice_date,
        'affected_items': affected_items
    }


def sklad_import_stats(request):
    """Statistics page showing latest imports by provider"""
    from django.db.models import Sum
    
    # Get provider filter from request
    provider_filter = request.GET.get('provider', '')
    
    # Base queryset for recent imports
    recent_imports_queryset = ImportLog.objects.all()
    if provider_filter:
        recent_imports_queryset = recent_imports_queryset.filter(provider=provider_filter)
    
    # Get recent imports (last 10)
    recent_imports = recent_imports_queryset[:10]
    
    # Get latest import for each provider
    latest_imports = {}
    
    for provider_code, provider_name in ImportLog.PROVIDER_CHOICES:
        latest_import = ImportLog.objects.filter(provider=provider_code).first()
        if latest_import:
            latest_imports[provider_code] = {
                "name": provider_name,
                "import": latest_import,
                "total_imports": ImportLog.objects.filter(provider=provider_code).count(),
                "successful_imports": ImportLog.objects.filter(provider=provider_code, is_successful=True).count(),
                "total_items_created": ImportLog.objects.filter(provider=provider_code).aggregate(
                    total=Sum("items_created")
                )["total"] or 0,
                "total_items_updated": ImportLog.objects.filter(provider=provider_code).aggregate(
                    total=Sum("items_updated")
                )["total"] or 0,
            }
    
    # Get total statistics (filtered if provider selected)
    total_imports = recent_imports_queryset.count()
    successful_imports = recent_imports_queryset.filter(is_successful=True).count()
    total_items_created = recent_imports_queryset.aggregate(
        total=Sum("items_created")
    )["total"] or 0
    total_items_updated = recent_imports_queryset.aggregate(
        total=Sum("items_updated")
    )["total"] or 0
    
    context = {
        "latest_imports": latest_imports,
        "recent_imports": recent_imports,
        "total_imports": total_imports,
        "successful_imports": successful_imports,
        "total_items_created": total_items_created,
        "total_items_updated": total_items_updated,
        "provider_filter": provider_filter,
        "provider_choices": ImportLog.PROVIDER_CHOICES,
    }
    
    return render(request, "dashboard/sklad_import_stats.html", context)


def sklad_import_detail(request, import_id):
    """Show detailed information about a specific import"""
    from django.shortcuts import get_object_or_404
    
    import_log = get_object_or_404(ImportLog, id=import_id)
    
    # Get affected items from the import log
    affected_items = import_log.affected_items or {'created': [], 'updated': []}
    
    context = {
        'import_log': import_log,
        'affected_items': affected_items,
    }
    
    return render(request, "dashboard/sklad_import_detail.html", context)


def sklad_import_delete(request, import_id):
    """Delete a specific import log"""
    from django.shortcuts import get_object_or_404, redirect
    from django.contrib import messages
    
    import_log = get_object_or_404(ImportLog, id=import_id)
    
    if request.method == 'POST':
        provider_name = import_log.get_provider_display()
        import_log.delete()
        messages.success(request, f'Импортът от {provider_name} ({import_log.invoice_date}) беше изтрит успешно.')
        return redirect('sklad_import_stats')
    
    context = {
        'import_log': import_log,
    }
    
    return render(request, "dashboard/sklad_import_confirm_delete.html", context)


def sklad_import_bulk_delete(request):
    """Bulk delete import logs"""
    from django.shortcuts import redirect
    from django.contrib import messages
    
    if request.method == 'POST':
        # Get all import logs
        import_logs = ImportLog.objects.all()
        count = import_logs.count()
        
        if count > 0:
            import_logs.delete()
            messages.success(request, f'Успешно изтрихте {count} импорт лога.')
        else:
            messages.info(request, 'Няма импорт логове за изтриване.')
        
        return redirect('sklad_import_stats')
    
    # Show confirmation page
    import_logs = ImportLog.objects.all()
    context = {
        'import_logs': import_logs,
        'total_count': import_logs.count()
    }
    
    return render(request, "dashboard/sklad_import_bulk_delete.html", context)


# Order Views
def order_create(request):
    """Create new order with items"""
    if request.method == 'POST':
        form = OrderForm(request.POST)
        item_formset = OrderItemFormSet(request.POST)
        action = request.POST.get('action', 'offer')  # Default to offer
        
        if form.is_valid() and item_formset.is_valid():
            order = form.save(commit=False)
            # Auto-generate order number
            if not order.order_number:
                last_order = Order.objects.order_by('-id').first()
                if last_order and last_order.order_number.isdigit():
                    order.order_number = str(int(last_order.order_number) + 1)
                else:
                    order.order_number = '1'
            # Auto-generate order date
            if not order.order_date:
                order.order_date = timezone.now().date()
            
            # Set status based on action
            if action == 'invoice':
                order.status = 'invoice'
            elif action == 'order':
                order.status = 'order'
            elif action == 'draft':
                order.status = 'offer'  # Save as offer for preview
            else:  # offer
                order.status = 'offer'
                
            order.save()
            
            # Save employees (many-to-many relationship)
            if 'employees' in form.cleaned_data:
                order.employees.set(form.cleaned_data['employees'])
            
            # Save order items
            item_formset.instance = order
            items = item_formset.save()
            
            # Only reduce sklad quantities for invoices and orders, not for offers
            if action == 'invoice' or action == 'order':
                for item in items:
                    if item.sklad_item:
                        try:
                            sklad_item = item.sklad_item
                            # Always reduce quantity (allow negative values to show restock needs)
                            sklad_item.quantity -= item.quantity
                            sklad_item.save()
                            
                            # Show warning if quantity goes negative
                            if sklad_item.quantity < 0:
                                messages.warning(request, f'Внимание: Артикул {sklad_item.article_number} има отрицателно количество ({sklad_item.quantity}). Необходимо е попълване на склада!')
                        except Exception as e:
                            messages.error(request, f'Грешка при обновяване на склада за артикул {item.article_number}: {str(e)}')
                
                # Create Invoice record for fakturi table
                from .models import Invoice
                from datetime import timedelta
                
                # Generate fiscal-compliant invoice number
                from datetime import datetime
                current_year = datetime.now().year
                
                # Get the last invoice number for this year
                last_invoice = Invoice.objects.filter(
                    invoice_number__startswith=f'{current_year}-'
                ).order_by('-invoice_number').first()
                
                if last_invoice and last_invoice.invoice_number.startswith(f'{current_year}-'):
                    # Extract the sequential number and increment
                    try:
                        last_number = int(last_invoice.invoice_number.split('-')[1])
                        next_number = last_number + 1
                    except (ValueError, IndexError):
                        next_number = 1
                else:
                    next_number = 1
                
                # Format: YYYY-XXXXXX (year + 6-digit sequential number)
                invoice_number = f'{current_year}-{next_number:06d}'
                
                # Set invoice dates
                invoice_date = order.order_date
                due_date = invoice_date + timedelta(days=30)  # 30 days payment term
                
                # Create invoice record
                invoice = Invoice.objects.create(
                    invoice_number=invoice_number,
                    order=order,
                    invoice_date=invoice_date,
                    due_date=due_date,
                    client_name=order.client_name,
                    client_address=order.client_address or '',
                    client_phone=order.client_phone or '',
                    car_brand_model=order.car_brand_model,
                    car_plate_number=order.car_plate_number or '',
                    car_vin=order.car_vin or '',
                    subtotal=order.total_without_vat,
                    vat_amount=order.total_vat,
                    total_amount=order.total_with_vat,
                    notes=order.notes or '',
                    status='sent'  # Default status
                )
            
            # Handle AJAX request for preview (draft action)
            if action == 'draft' or request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'order_id': order.id,
                    'order_number': order.order_number,
                    'message': f'Поръчка {order.order_number} е запазена успешно!'
                })
            
            # Generate PDF based on action
            from .pdf_generator import generate_invoice_pdf, generate_offer_pdf
            
            if action == 'invoice':
                messages.success(request, f'Поръчка {order.order_number} е създадена и фактурата е генерирана успешно!')
                return generate_invoice_pdf(order)
            elif action == 'order':
                messages.success(request, f'Поръчка {order.order_number} е създадена и поръчката е генерирана успешно!')
                return generate_invoice_pdf(order)  # Use invoice PDF generator but will show "Поръчка" in the template
            else:  # offer
                messages.success(request, f'Поръчка {order.order_number} е създадена и офертата е генерирана успешно!')
                return generate_offer_pdf(order)
        else:
            # Handle form errors for AJAX requests
            if request.headers.get('Content-Type') == 'application/json':
                return JsonResponse({
                    'success': False,
                    'error': 'Грешка при валидация на формата',
                    'form_errors': form.errors,
                    'item_errors': item_formset.errors
                })
    else:
        form = OrderForm()
        item_formset = OrderItemFormSet()
    
    return render(request, 'dashboard/order_form.html', {
        'form': form,
        'item_formset': item_formset,
        'title': 'Нова поръчка',
        'action': 'Създай'
    })


def order_generate_offer(request, pk):
    """Generate offer PDF for existing order"""
    order = get_object_or_404(Order, pk=pk)
    from .pdf_generator import generate_offer_pdf
    return generate_offer_pdf(order)


def order_generate_invoice(request, pk):
    """Generate invoice PDF for existing order"""
    order = get_object_or_404(Order, pk=pk)
    from .pdf_generator import generate_invoice_pdf
    return generate_invoice_pdf(order)


def order_edit(request, pk):
    """Edit existing order with items"""
    order = get_object_or_404(Order, pk=pk)
    
    if request.method == 'POST':
        form = OrderForm(request.POST, instance=order)
        item_formset = OrderItemFormSet(request.POST, instance=order)
        
        if form.is_valid() and item_formset.is_valid():
            # Store original items for inventory restoration
            original_items = list(order.order_items.all())
            
            # Save the order and items
            form.save()
            new_items = item_formset.save()
            
            # Restore sklad quantities from original items
            for original_item in original_items:
                if original_item.sklad_item:
                    try:
                        sklad_item = original_item.sklad_item
                        sklad_item.quantity += original_item.quantity
                        sklad_item.save()
                    except Exception as e:
                        messages.error(request, f'Грешка при възстановяване на склада за артикул {original_item.article_number}: {str(e)}')
            
            # Reduce sklad quantities for new items
            for item in new_items:
                if item.sklad_item:
                    try:
                        sklad_item = item.sklad_item
                        # Always reduce quantity (allow negative values to show restock needs)
                        sklad_item.quantity -= item.quantity
                        sklad_item.save()
                        
                        # Show warning if quantity goes negative
                        if sklad_item.quantity < 0:
                            messages.warning(request, f'Внимание: Артикул {sklad_item.article_number} има отрицателно количество ({sklad_item.quantity}). Необходимо е попълване на склада!')
                    except Exception as e:
                        messages.error(request, f'Грешка при обновяване на склада за артикул {item.article_number}: {str(e)}')
            
            messages.success(request, f'Поръчка {order.order_number} е обновена успешно!')
            return redirect('poruchki')
    else:
        form = OrderForm(instance=order)
        item_formset = OrderItemFormSet(instance=order)
    
    return render(request, 'dashboard/order_form.html', {
        'form': form,
        'item_formset': item_formset,
        'order': order,
        'title': f'Редактиране на поръчка {order.order_number}',
        'action': 'Запази'
    })


def order_delete(request, pk):
    """Delete order"""
    order = get_object_or_404(Order, pk=pk)
    
    if request.method == 'POST':
        # Restore sklad quantities before deleting the order
        for item in order.order_items.all():
            if item.sklad_item:
                try:
                    sklad_item = item.sklad_item
                    sklad_item.quantity += item.quantity
                    sklad_item.save()
                except Exception as e:
                    messages.error(request, f'Грешка при възстановяване на склада за артикул {item.article_number}: {str(e)}')
        
        order_number = order.order_number
        order.delete()
        messages.success(request, f'Поръчка {order_number} е изтрита успешно!')
        return redirect('poruchki')
    
    return render(request, 'dashboard/order_confirm_delete.html', {
        'order': order
    })


def order_detail(request, pk):
    """View order details with items"""
    order = get_object_or_404(Order, pk=pk)
    items = order.order_items.all()
    return render(request, 'dashboard/order_detail.html', {
        'order': order,
        'items': items
    })


# Autocomplete views for orders
def order_autocomplete_car_vin(request):
    """API endpoint for car VIN autocomplete"""
    query = request.GET.get('q', '').strip()
    
    if not query or len(query) < 3:
        return JsonResponse({'suggestions': []})
    
    # Search for cars by VIN
    cars = Car.objects.filter(
        vin__icontains=query,
        is_active=True
    ).select_related('customer')[:10]
    
    suggestions = []
    for car in cars:
        suggestions.append({
            'id': car.id,
            'vin': car.vin,
            'brand_model': car.brand_model,
            'plate_number': car.plate_number,
            'customer_name': car.customer.customer_name,
            'display_text': f"{car.brand_model} - {car.vin} ({car.customer.customer_name})"
        })
    
    return JsonResponse({'suggestions': suggestions})


def order_autocomplete_car_plate(request):
    """API endpoint for car plate number autocomplete"""
    query = request.GET.get('q', '').strip()
    
    if not query or len(query) < 2:
        return JsonResponse({'suggestions': []})
    
    # Search for cars by plate number
    cars = Car.objects.filter(
        plate_number__icontains=query,
        is_active=True
    ).select_related('customer')[:10]
    
    suggestions = []
    for car in cars:
        suggestions.append({
            'id': car.id,
            'vin': car.vin,
            'brand_model': car.brand_model,
            'plate_number': car.plate_number,
            'customer_name': car.customer.customer_name,
            'display_text': f"{car.brand_model} - {car.plate_number} ({car.customer.customer_name})"
        })
    
    return JsonResponse({'suggestions': suggestions})


def order_autocomplete_client(request):
    """API endpoint for client autocomplete"""
    query = request.GET.get('q', '').strip()
    
    if not query or len(query) < 2:
        return JsonResponse({'suggestions': []})
    
    # Search for clients by name
    clients = Customer.objects.filter(
        customer_name__icontains=query,
        active=True
    )[:10]
    
    suggestions = []
    for client in clients:
        suggestions.append({
            'id': client.id,
            'name': client.customer_name,
            'address': client.full_address,
            'phone': client.telno,
            'display_text': f"{client.customer_name} - {client.full_address}"
        })
    
    return JsonResponse({'suggestions': suggestions})


def order_autocomplete_sklad(request):
    """API endpoint for sklad autocomplete for order items"""
    query = request.GET.get('q', '').strip()
    field = request.GET.get('field', 'article_number')  # 'article_number' or 'name'
    
    if not query or len(query) < 2:
        return JsonResponse({'suggestions': []})
    
    # Validate field parameter
    if field not in ['article_number', 'name']:
        field = 'article_number'
    
    # Search for matching items
    items = Sklad.objects.filter(
        **{f'{field}__icontains': query},
        is_active=True
    ).values('id', 'article_number', 'name', 'unit', 'quantity', 'purchase_price')[:10]
    
    suggestions = []
    for item in items:
        suggestions.append({
            'id': item['id'],
            'article_number': item['article_number'],
            'name': item['name'],
            'unit': item['unit'],
            'quantity': float(item['quantity']),
            'purchase_price': float(item['purchase_price']),
            'display_text': f"{item['article_number']} - {item['name']}"
        })
    
    return JsonResponse({'suggestions': suggestions})


def order_get_car_info(request):
    """Get car information by VIN, plate number, or car ID"""
    vin = request.GET.get('vin', '').strip()
    plate = request.GET.get('plate', '').strip()
    car_id = request.GET.get('car_id', '').strip()
    
    car = None
    if car_id:
        car = Car.objects.filter(id=car_id, is_active=True).select_related('customer').first()
    elif vin:
        car = Car.objects.filter(vin=vin, is_active=True).select_related('customer').first()
    elif plate:
        car = Car.objects.filter(plate_number=plate, is_active=True).select_related('customer').first()
    
    if car:
        return JsonResponse({
            'success': True,
            'car': {
                'id': car.id,
                'brand_model': car.brand_model,
                'vin': car.vin,
                'plate_number': car.plate_number,
                'year': car.year,
                'color': car.color,
                'engine_number': car.engine_number,
            },
            'client': {
                'id': car.customer.id,
                'name': car.customer.customer_name,
                'address': car.customer.full_address,
                'phone': car.customer.telno,
            }
        })
    else:
        return JsonResponse({'success': False, 'message': 'Кола не е намерена'})


def order_get_client_info(request):
    """Get client information by client ID"""
    client_id = request.GET.get('client_id', '').strip()
    
    if client_id:
        try:
            client = Customer.objects.get(id=client_id, active=True)
            return JsonResponse({
                'success': True,
                'client': {
                    'id': client.id,
                    'name': client.customer_name,
                    'address': client.full_address,
                    'phone': client.telno,
                }
            })
        except Customer.DoesNotExist:
            return JsonResponse({'success': False, 'message': 'Клиент не е намерен'})
    else:
        return JsonResponse({'success': False, 'message': 'Не е предоставен ID на клиент'})


def order_sklad_modal_data(request):
    """Get sklad data for the modal with pagination and filtering"""
    search_query = request.GET.get('search', '').strip()
    unit_filter = request.GET.get('unit', '').strip()
    page = int(request.GET.get('page', 1))
    per_page = 20
    
    # Start with all active sklad items
    items = Sklad.objects.filter(is_active=True)
    
    # Apply search filter - search both article_number and name
    if search_query:
        from django.db.models import Q
        items = items.filter(
            Q(article_number__icontains=search_query) | 
            Q(name__icontains=search_query)
        )
    
    # Apply unit filter
    if unit_filter:
        items = items.filter(unit=unit_filter)
    
    # Order by article number
    items = items.order_by('article_number')
    
    # Pagination
    paginator = Paginator(items, per_page)
    page_obj = paginator.get_page(page)
    
    # Prepare data
    items_data = []
    for item in page_obj:
        items_data.append({
            'id': item.id,
            'article_number': item.article_number,
            'name': item.name,
            'unit': item.unit,
            'quantity': float(item.quantity),
            'purchase_price': float(item.purchase_price),
            'total_value': float(item.total_value),
        })
    
    return JsonResponse({
        'items': items_data,
        'pagination': {
            'current_page': page_obj.number,
            'total_pages': paginator.num_pages,
            'has_previous': page_obj.has_previous(),
            'has_next': page_obj.has_next(),
            'previous_page': page_obj.previous_page_number() if page_obj.has_previous() else None,
            'next_page': page_obj.next_page_number() if page_obj.has_next() else None,
        },
        'total_count': paginator.count
    })


def order_sklad_units(request):
    """Get available units for the sklad modal filter"""
    units = Sklad.objects.filter(is_active=True).values_list('unit', flat=True).distinct().order_by('unit')
    units_list = [unit for unit in units if unit]
    return JsonResponse({'units': units_list})


def currency_rate(request):
    """Get current EUR to BGN exchange rate"""
    from .currency_utils import get_currency_info
    info = get_currency_info()
    return JsonResponse({'rate': info['eur_rate']})


def order_preview_offer(request, pk):
    """Preview offer in modal"""
    order = get_object_or_404(Order, pk=pk)
    return render(request, 'dashboard/order_preview_offer.html', {
        'order': order
    })


def order_preview_invoice(request, pk):
    """Preview invoice in modal"""
    order = get_object_or_404(Order, pk=pk)
    return render(request, 'dashboard/order_preview_invoice.html', {
        'order': order
    })


def order_preview_order(request, pk):
    """Preview order in modal"""
    order = get_object_or_404(Order, pk=pk)
    return render(request, 'dashboard/order_preview_order.html', {
        'order': order
    })


def order_convert_to_invoice(request, pk):
    """Convert offer to invoice"""
    order = get_object_or_404(Order, pk=pk)
    
    if request.method == 'POST':
        # Change status from offer to invoice
        order.status = 'invoice'
        order.save()
        
        # Create invoice record
        from .models import Invoice
        from datetime import timedelta
        
        # Check if invoice already exists
        if not hasattr(order, 'invoice'):
            invoice = Invoice.objects.create(
                order=order,
                invoice_date=order.order_date or timezone.now().date(),
                due_date=(order.order_date or timezone.now().date()) + timedelta(days=30),
                client_name=order.client_name or '',
                client_address=order.client_address or '',
                client_phone=order.client_phone or '',
                client_tax_number='',  # Order doesn't have tax number field
                car_brand_model=order.car_brand_model or '',
                car_plate_number=order.car_plate_number or '',
                car_vin=order.car_vin or '',
                subtotal=float(order.total_without_vat),
                vat_amount=float(order.total_with_vat) - float(order.total_without_vat),
                total_amount=float(order.total_with_vat),
                status='sent',
                notes=order.notes or ''
            )
            messages.success(request, f'Поръчка {order.order_number} е конвертирана в фактура {invoice.invoice_number} успешно!')
        else:
            messages.info(request, f'Поръчка {order.order_number} вече има създадена фактура!')
        
        return redirect('pregled_poruchki')
    
    return render(request, 'dashboard/order_convert_to_invoice.html', {
        'order': order
    })


# Invoice Views
def fakturi(request):
    """Invoices list page with search and filters"""
    from django.db.models import Q
    from django.core.paginator import Paginator
    from .models import Invoice
    
    # Get all invoices ordered by most recent first
    invoices = Invoice.objects.all().order_by('-invoice_date', '-created_at')
    
    # Search functionality with smart VIN logic
    search_query = request.GET.get('search', '').strip()
    if search_query:
        # Always search by invoice number, client name, car details
        search_conditions = (
            Q(invoice_number__icontains=search_query) |
            Q(client_name__icontains=search_query) |
            Q(car_brand_model__icontains=search_query) |
            Q(car_plate_number__icontains=search_query) |
            Q(notes__icontains=search_query)
        )
        
        # Only search by VIN if search term is 5+ characters (smart VIN search)
        if len(search_query) >= 5:
            search_conditions |= Q(car_vin__icontains=search_query)
        
        invoices = invoices.filter(search_conditions)
    
    # Status filter
    status_filter = request.GET.get('status', '').strip()
    if status_filter:
        invoices = invoices.filter(status=status_filter)
    
    # Date range filter
    date_from = request.GET.get('date_from', '').strip()
    date_to = request.GET.get('date_to', '').strip()
    
    if date_from:
        try:
            from datetime import datetime
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            invoices = invoices.filter(invoice_date__gte=date_from_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    if date_to:
        try:
            from datetime import datetime
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            invoices = invoices.filter(invoice_date__lte=date_to_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    # Pagination
    paginator = Paginator(invoices, 20)  # Show 20 invoices per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Get statistics
    total_invoices = Invoice.objects.count()
    draft_invoices = Invoice.objects.filter(status='draft').count()
    sent_invoices = Invoice.objects.filter(status='sent').count()
    paid_invoices = Invoice.objects.filter(status='paid').count()
    overdue_invoices = Invoice.objects.filter(status='overdue').count()
    
    # Calculate total revenue
    total_revenue = sum(float(invoice.total_amount) for invoice in Invoice.objects.filter(status='paid'))
    pending_revenue = sum(float(invoice.total_amount) for invoice in Invoice.objects.exclude(status__in=['paid', 'cancelled']))
    
    context = {
        'invoices': page_obj,
        'search_query': search_query,
        'status_filter': status_filter,
        'date_from': date_from,
        'date_to': date_to,
        'status_choices': Invoice.INVOICE_STATUS_CHOICES,
        'total_invoices': total_invoices,
        'draft_invoices': draft_invoices,
        'sent_invoices': sent_invoices,
        'paid_invoices': paid_invoices,
        'overdue_invoices': overdue_invoices,
        'total_revenue': total_revenue,
        'pending_revenue': pending_revenue,
    }
    
    return render(request, 'dashboard/fakturi.html', context)


def invoice_detail(request, pk):
    """Invoice detail view"""
    from .models import Invoice
    invoice = get_object_or_404(Invoice, pk=pk)
    
    context = {
        'invoice': invoice,
    }
    
    return render(request, 'dashboard/invoice_detail.html', context)


def invoice_search_ajax(request):
    """AJAX endpoint for invoice search with smart VIN logic"""
    from django.template.loader import render_to_string
    from django.core.paginator import Paginator
    from .models import Invoice
    
    search_query = request.GET.get('search', '').strip()
    status_filter = request.GET.get('status', '').strip()
    date_from = request.GET.get('date_from', '').strip()
    date_to = request.GET.get('date_to', '').strip()
    page = int(request.GET.get('page', 1))
    
    # Start with all invoices ordered by most recent first
    invoices = Invoice.objects.all().order_by('-invoice_date', '-created_at')
    
    # Apply search with smart VIN logic
    if search_query:
        # Always search by invoice number, client name, car details
        search_conditions = (
            Q(invoice_number__icontains=search_query) |
            Q(client_name__icontains=search_query) |
            Q(car_brand_model__icontains=search_query) |
            Q(car_plate_number__icontains=search_query) |
            Q(notes__icontains=search_query)
        )
        
        # Only search by VIN if search term is 5+ characters (smart VIN search)
        if len(search_query) >= 5:
            search_conditions |= Q(car_vin__icontains=search_query)
        
        invoices = invoices.filter(search_conditions)
    
    # Apply status filter
    if status_filter:
        invoices = invoices.filter(status=status_filter)
    
    # Apply date range filters
    if date_from:
        try:
            from datetime import datetime
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            invoices = invoices.filter(invoice_date__gte=date_from_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    if date_to:
        try:
            from datetime import datetime
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            invoices = invoices.filter(invoice_date__lte=date_to_obj)
        except ValueError:
            pass  # Invalid date format, ignore filter
    
    # Pagination
    paginator = Paginator(invoices, 20)  # 20 invoices per page
    page_obj = paginator.get_page(page)
    
    # Calculate statistics
    total_invoices = Invoice.objects.count()
    draft_invoices = Invoice.objects.filter(status='draft').count()
    sent_invoices = Invoice.objects.filter(status='sent').count()
    paid_invoices = Invoice.objects.filter(status='paid').count()
    overdue_invoices = Invoice.objects.filter(status='overdue').count()
    
    # Calculate total revenue
    total_revenue = sum(float(invoice.total_amount) for invoice in Invoice.objects.filter(status='paid'))
    pending_revenue = sum(float(invoice.total_amount) for invoice in Invoice.objects.exclude(status__in=['paid', 'cancelled']))
    
    # Render table and pagination
    table_html = render_to_string('dashboard/invoice_table.html', {
        'invoices': page_obj,
    })
    
    pagination_html = render_to_string('dashboard/invoice_pagination.html', {
        'invoices': page_obj,
        'request': request,
    })
    
    return JsonResponse({
        'table_html': table_html,
        'pagination_html': pagination_html,
        'stats': {
            'total_invoices': total_invoices,
            'draft_invoices': draft_invoices,
            'sent_invoices': sent_invoices,
            'paid_invoices': paid_invoices,
            'overdue_invoices': overdue_invoices,
            'total_revenue': total_revenue,
            'pending_revenue': pending_revenue,
            'total_pages': paginator.num_pages,
        }
    })
